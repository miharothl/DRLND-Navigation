#!/usr/bin/env python3
import argparse

from config.config import get_env_config, get_app_config
from dqn import logging
from dqn.environment import Environment
from dqn.logging import init_logging, set_logging_level, transform_verbose_count_to_logging_level
import logging
import logging.config
from dqn.play import Play
from dqn.train import Train
import numpy as np

def parse_arguments(params):
    ap = argparse.ArgumentParser(description="Runs data prep",
                                 formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    ap.add_argument("-v", "--verbose", dest="verbose_count",
                    action="count", default=0,
                    help="Increases log verbosity for each occurrence.")
    ap.add_argument('-t', '--train',
                    action='store_true',
                    help="Train")
    ap.add_argument('-p', '--play',
                    action='store_true',
                    help="play")
    ap.add_argument('-e', '--env',
                    default='cartpole',
                    help="Environment")
    ap.add_argument('-l', '--list_envs',
                    action='store_true',
                    help="List RL environment")
    ap.add_argument("-m", '--select_model',
                    default='score_max',
                    choices=['score_max', 'score_min', 'score_median'],
                    help="Model selection criteria")

    args = ap.parse_args()

    return args


def main():
    init_logging(logging.ERROR)

    params = get_app_config()

    try:
        args = parse_arguments(params)

        set_logging_level(transform_verbose_count_to_logging_level(args.verbose_count))

        logging.debug(params)

        config = get_env_config()
        environment = Environment(config)
        environment.set_env(args.env)
        agent = environment.get_agent()
        env = environment.get_env()

        if args.list_envs:
            environment.list_envs()
        elif args.train:
            train = Train(model_id=environment.get_model_id())

            train.dqn_banana(agent, env)


            # train.dqn(agent, env)
        elif args.play:

            brain_name = env.brain_names[0]
            brain = env.brains[brain_name]

            # reset the environment
            env_info = env.reset(train_mode=True)[brain_name]

            # number of agents in the environment
            print('Number of agents:', len(env_info.agents))

            # number of actions
            action_size = brain.vector_action_space_size
            print('Number of actions:', action_size)

            # examine the state space
            state = env_info.vector_observations[0]
            print('States look like:', state)
            state_size = len(state)
            print('States have length:', state_size)

            env_info = env.reset(train_mode=False)[brain_name]  # reset the environment
            state = env_info.vector_observations[0]  # get the current state
            score = 0  # initialize the score
            while True:
                action = np.random.randint(action_size)  # select an action
                env_info = env.step(action)[brain_name]  # send the action to the environment
                next_state = env_info.vector_observations[0]  # get the next state
                reward = env_info.rewards[0]  # get the reward
                done = env_info.local_done[0]  # see if episode has finished
                score += reward  # update the score
                state = next_state  # roll over the state to next time step
                if done:  # exit loop if episode finished
                    print('done')
                    break

            print("Score: {}".format(score))


            play = Play(model_id=environment.get_model_id(),
                        env=env,
                        agent=agent)
            if args.select_model == 'score_max':
                # play.play()
                play.play()




            elif args.select_model == 'score_median':
                play.play(score_max=False, score_med=True)
            else:
                play.play(score_max=False, score_med=False)

        env.close()

    except Exception as e:
        logging.exception("Something went wrong :-(")

    finally:
        logging.shutdown()


if __name__ == '__main__':
    main()
